[{"name": "app.py", "content": "from shiny import App, render, ui, Inputs, Outputs, Session, reactive\nimport pandas as pd\nimport time\nimport matplotlib.pyplot as plt\nfrom htmltools import css\nfrom shinywidgets import output_widget, reactive_read, register_widget\nimport ipyleaflet as L\nimport ipywidgets as widgets\nimport json\nfrom datetime import date, datetime, timedelta\nfrom io import StringIO\nfrom shiny_download import get_url\nimport asyncio\n\n# dane\nurl_ar = r'https://raw.githubusercontent.com/uni-lec-laboratory/lab-2223-group1-website/main/data/predictions/ar_seq2seq.csv'\nurl_ar_pca = r'https://raw.githubusercontent.com/uni-lec-laboratory/lab-2223-group1-website/main/data/predictions/ar_seq2seq_pca.csv'\nurl_dnn = r'https://raw.githubusercontent.com/uni-lec-laboratory/lab-2223-group1-website/main/data/predictions/dnn_seq2seq.csv'\nurl_rnn = r'https://raw.githubusercontent.com/uni-lec-laboratory/lab-2223-group1-website/main/data/predictions/rnn_seq2seq.csv'\nurl_baseline = r'https://raw.githubusercontent.com/uni-lec-laboratory/lab-2223-group1-website/main/data/predictions/baseline.csv'\nurl_six_cities = r'https://raw.githubusercontent.com/uni-lec-laboratory/lab-2223-group1-website/main/data/csv/six_cities.csv'\nurl_lat_lon = r'https://raw.githubusercontent.com/uni-lec-laboratory/lab-2223-group1-website/main/data/cities_lat_lon_data.json'\nurl_city_list = r'https://raw.githubusercontent.com/uni-lec-laboratory/lab-2223-group1-website/main/data/city_list.txt'\nurl_var_names = r'https://raw.githubusercontent.com/uni-lec-laboratory/lab-2223-group1-website/main/data/variable_names.txt'\n\napp_ui = ui.page_fluid(\n    ui.navset_tab_card(\n    \n        ui.nav(\"Maps\", \n               \n            ui.panel_title(ui.tags.h1(\"Awesome map\")),\n\n            ui.layout_sidebar(\n            ui.panel_main(\n                ui.panel_well(\n                    # mapa\n                    output_widget(\"map\",height='450px'),\n                )),\n            ui.panel_sidebar(\n                # wyb\u00f3r daty\n                ui.input_date('date',\n                              'Choose date',\n                              value = \"2023-05-18\"\n                              ),\n                # wyb\u00f3r zmiennej\n                ui.input_radio_buttons('var',\n                                       \"Choose variables\",\n                                        choices = [''],\n                                    ),\n                # napis z informacj\u0105\n                ui.output_ui('map_bounds')\n            )\n            ),\n        ),\n        ui.nav(\"Pollution\", \n               \n            ui.panel_title(ui.tags.h1(\"Pollution forecast\")),\n\n            ui.layout_sidebar(\n\n                ui.panel_sidebar(\n                        # wyb\u00f3r miasta\n                        ui.panel_well(\n                            ui.input_select('slct_city',\n                                            \"Choose city\",\n                                            choices = [''])\n                            ),\n                        # wyb\u00f3r zmiennych\n                        ui.panel_well(\n                            ui.input_checkbox_group('slct_var',\n                                                    \"Choose variables\",\n                                                    choices=[''])\n                        ),\n                        # wyb\u00f3r dat\n                        ui.panel_well(\n                            ui.input_date_range('dates',\n                                            \"Select date:\",\n                                            weekstart = 1,\n                                            startview = \"year\"\n                                            ),\n                        ),\n                        width=3\n                ),\n\n            ui.panel_main(\n                    ui.panel_well(\n                        # wyb\u00f3r modelu\n                        ui.input_radio_buttons(\"model\",\n                                               \"Choose model\",\n                                               choices = ['']\n                                               ),\n                        # wykresy\n                        ui.output_plot(\"plots\",height='450px'),\n                    ),\n                    width=9\n                ),\n            ),\n        ),\n    ),\n)\n\ndef server(input: Inputs, output: Outputs, session: Session):\n\n    reactive_df_predicted_ar = reactive.Value(pd.DataFrame())\n    reactive_df_predicted_ar_pca = reactive.Value(pd.DataFrame())\n    reactive_df_predicted_dnn = reactive.Value(pd.DataFrame())\n    reactive_df_predicted_rnn = reactive.Value(pd.DataFrame())\n    reactive_df_predicted_baseline = reactive.Value(pd.DataFrame())\n\n    reactive_df_data = reactive.Value(pd.DataFrame())\n    reactive_df_city = reactive.Value(pd.DataFrame())\n    reactive_df_var = reactive.Value(pd.DataFrame())\n    reactive_city_lat_lon = reactive.Value()\n    \n    @reactive.Effect\n    async def _():\n        # lista miast\n        response = await get_url(url_city_list, 'string')\n        data = StringIO(response.data)\n        reactive_df_city.set(pd.read_csv(data, header=0))\n        city_options = [item[1]['city'] for item in (reactive_df_city().to_dict('index')).items()]\n        ui.update_select(\n            'slct_city',\n            choices = city_options\n        )\n        \n        # lista zmiennych\n        response = await get_url(url_var_names, 'string')\n        data = StringIO(response.data)\n        reactive_df_var.set(pd.read_csv(data, header=0))\n        df_var = reactive_df_var()[7:]\n        df_var.columns = ['var_name','var_value']\n        df_var_items = (df_var.to_dict('index')).items()\n        var_options = {item[1]['var_value'] : item[1]['var_name'] for item in df_var_items}\n        var_options2 = {item[1]['var_value'] : item[1]['var_name'] for item in df_var_items if item[1]['var_value'] not in ['nh3','no']}\n\n        ui.update_radio_buttons(\n            'var',\n            choices = var_options2\n        )\n\n        ui.update_checkbox_group(\n            'slct_var',\n            choices = var_options\n        )\n\n        # lista dost\u0119pnych modeli\n        models = {'ar_pca':'AR PCA','ar':'AR','dnn':'DNN','rnn':'RNN','baseline':'Baseline'}\n        ui.update_radio_buttons(\n            'model',\n            choices = models,\n            inline=True\n        )\n        # dane\n        response = await get_url(url_six_cities, 'string')\n        data = StringIO(response.data)\n        reactive_df_data.set(pd.read_csv(data, header=0))\n        reactive_df_data()['dt'] = pd.to_datetime(reactive_df_data()['dt'])\n\n        response = await get_url(url_ar, 'string')\n        data = StringIO(response.data)\n        reactive_df_predicted_ar.set(pd.read_csv(data, header=0))\n        reactive_df_predicted_ar()['dt'] = pd.to_datetime(reactive_df_predicted_ar()['dt'])\n\n        # daty\n        # daty pocz\u0105tkowa i ko\u0144cowa w danych\n        start = min(reactive_df_data()['dt']).date()\n        end1 = max(reactive_df_data()['dt']).date()\n        end = max(reactive_df_predicted_ar()['dt']).date()\n\n        ui.update_date(\n            'date',\n            value=end1 - timedelta(days=1),\n            min= start,\n            max= end1 - timedelta(days=1)\n        )\n\n        ui.update_date_range(\n            'dates',\n            start=start,\n            end=end,\n            min=start,\n            max=end,\n        )\n\n        # wsp\u00f3\u0142rz\u0119dne geograficzne miast\n        response = await get_url(url_lat_lon, 'json')\n        data = response.data\n        reactive_city_lat_lon.set(data)\n\n        # wczytanie predykcji\n        response = await get_url(url_ar_pca, 'string')\n        data = StringIO(response.data)\n        reactive_df_predicted_ar_pca.set(pd.read_csv(data, header=0))\n        reactive_df_predicted_ar_pca()['dt'] = pd.to_datetime(reactive_df_predicted_ar_pca()['dt'])\n\n        response = await get_url(url_rnn, 'string')\n        data = StringIO(response.data)\n        reactive_df_predicted_rnn.set(pd.read_csv(data, header=0))\n        reactive_df_predicted_rnn()['dt'] = pd.to_datetime(reactive_df_predicted_rnn()['dt'])\n\n        response = await get_url(url_dnn, 'string')\n        data = StringIO(response.data)\n        reactive_df_predicted_dnn.set(pd.read_csv(data, header=0))\n        reactive_df_predicted_dnn()['dt'] = pd.to_datetime(reactive_df_predicted_dnn()['dt'])\n\n        response = await get_url(url_baseline, 'string')\n        data = StringIO(response.data)\n        reactive_df_predicted_baseline.set(pd.read_csv(data, header=0))\n        reactive_df_predicted_baseline()['dt'] = pd.to_datetime(reactive_df_predicted_baseline()['dt'])\n\n    # funkcja tworz\u0105ca wycinek danych w zale\u017cno\u015bci od wybranego miasta i czasu\n    @reactive.Calc\n    def df_section():\n        if(input.model() == 'ar_pca'):  # dane predykcji w zale\u017cno\u015bci od wyboru u\u017cytkownika\n            df_predicted = reactive_df_predicted_ar_pca()      \n        elif(input.model() == 'ar'):\n            df_predicted = reactive_df_predicted_ar()    \n        elif(input.model() == 'dnn'):\n            df_predicted = reactive_df_predicted_dnn() \n        elif(input.model() == 'rnn'):\n            df_predicted = reactive_df_predicted_rnn()\n        elif(input.model() == 'baseline'):\n            df_predicted = reactive_df_predicted_baseline()   \n\n        df_predicted['predicted'] = 1   # dodatkowa kolumna wskazuj\u0105ca czy jest to predykcja czy nie\n        df_data = reactive_df_data()\n        df_data['predicted'] = 0\n        df = pd.concat([df_data,df_predicted],ignore_index=True)\n\n        df = df[df[\"city\"] == input.slct_city()] # wycinek z wybranym miastem\n\n        df['dt_unix'] = df['dt'].apply(lambda row: time.mktime(row.timetuple())) # dodanie nowej kolumny z czasem uniksowym\n\n        start =  input.dates()[0] # wybrane daty\n        end = input.dates()[1]\n        start_date = time.mktime(start.timetuple()) # zamiana wybranych dat na czas uniksowy\n        end_date = time.mktime(end.timetuple())\n\n        mask = (df['dt_unix'] >= start_date) & (df['dt_unix'] <= end_date) # wycinek z wybranym czasem\n        df = df.loc[mask]\n\n        return df\n    \n    # funkcja tworz\u0105ca wykresy dla wybranych zmiennych\n    @output\n    @render.plot\n    def plots():\n        df =  df_section()\n        df_var = reactive_df_var()[7:]\n        df_var.columns = ['var_name','var_value']\n        df_var_items = (df_var.to_dict('index')).items()\n        var_options = {item[1]['var_value'] : item[1]['var_name'] for item in df_var_items}\n\n        plt.style.use('ggplot')\n        fig, ax = plt.subplots(1, 2, figsize=(20, 8))\n        ax = ax.ravel()\n        for var, i in zip(input.slct_var(), range(0,2)):\n            \n            # wydzielenie zbirow historycznych i predykcji\n            mask1 = df['predicted'] == 0 \n            mask2 = df['predicted'] == 1\n\n            ax[i].plot(df['dt'][mask1],df[var][mask1], color='#569DAA')\n            ax[i].plot(df['dt'][mask2],df[var][mask2], color='#F2A950')\n            ax[i].fill_between(df['dt'][mask1],df[var][mask1], color='#569DAA', alpha=0.5) # wypelnienie obszaru pod wykresem\n            ax[i].fill_between(df['dt'][mask2],df[var][mask2], color='#F2A950', alpha=0.5)\n            \n            # ustawienie parametr\u00f3w wykresu\n            ax[i].set_title(var_options[var])\n            ax[i].set_xlabel('date')\n            ax[i].set_xlim(input.dates()[0], input.dates()[1])\n            ax[i].set_ylim(bottom=0)\n            fig.autofmt_xdate()\n\n        return fig\n\n    # MAPA\n    # Initialize and display when the session starts (1)\n    map = L.Map(center=(52.565162, 19.252522), zoom=6, scroll_wheel_zoom=True, close_popup_on_click=False)\n    # Add a distance scale\n    map.add_control(L.leaflet.ScaleControl(position=\"bottomleft\"))\n    register_widget(\"map\", map)\n\n    # funkcja tworz\u0105ca wycinek danych w zale\u017cno\u015bci od wybranej daty\n    @reactive.Calc\n    def df_time_section():\n        df_copy = reactive_df_data()\n\n        df_copy['dt_unix'] = df_copy['dt'].apply(lambda row: time.mktime(row.timetuple())) # dodanie nowej kolumny z czasem uniksowym\n\n        d =  input.date()\n        data = time.mktime(d.timetuple()) # zamiana wybranych dat na czas uniksowy\n        mask = (df_copy['dt_unix'] >= data) # wycinek z wybranym czasem\n        df_copy = df_copy.loc[mask]\n\n        return df_copy\n    \n    # funkcja do znacznik\u00f3w na mapie\n    @reactive.Effect\n    def _():\n        df_time_sec = df_time_section()\n        data_cities_lat_lon = reactive_city_lat_lon()\n\n        # Create markers\n        for city in data_cities_lat_lon:\n            df = df_time_sec[df_time_sec[\"city\"] == city]\n            \n            start_t = pd.to_datetime(df['dt'].values[0]) + timedelta(hours = 8)     # \u015bredni poziom zanieczyszczenia 8.00 - 20.00\n            end_t = pd.to_datetime(df['dt'].values[0]) + timedelta(hours = 20)\n\n            df.set_index('dt', inplace=True)\n            df_new = df[start_t:end_t]\n\n            icons_urls = {'good':'https://cdn-icons-png.flaticon.com/512/725/725070.png',       # ikony w zale\u017cno\u015bci od poziomu zanieczysczenia\n                          'fair':'https://cdn-icons-png.flaticon.com/512/725/725105.png',\n                          'moderate':'https://cdn-icons-png.flaticon.com/512/725/725085.png',\n                          'poor':'https://cdn-icons-png.flaticon.com/512/725/725099.png',\n                          'very_poor':'https://cdn-icons-png.flaticon.com/512/725/725117.png'}\n            \n            var_limits = {'co':[4400,9400,12400,15400],         # pozimy zanieczyszczenia poszczeg\u00f3lnymi zwi\u0105zkami\n                          'no2':[40,70,150,200],\n                          'o3':[60,100,140,180],\n                          'so2':[20,80,250,350],\n                          'pm2_5':[10,25,50,75],\n                          'pm10':[20,50,100,200]}\n\n            if (input.var() != ''):\n                avg_var = df_new[input.var()].mean()\n                if avg_var < var_limits[input.var()][0]:\n                    icon = L.Icon(icon_url = icons_urls['good'],icon_size=[30, 30]) # good\n                elif avg_var >= var_limits[input.var()][0] and avg_var < var_limits[input.var()][1]:\n                    icon = L.Icon(icon_url = icons_urls['fair'],icon_size=[30, 30]) # fair\n                elif avg_var >= var_limits[input.var()][1] and avg_var < var_limits[input.var()][2]:\n                    icon = L.Icon(icon_url = icons_urls['moderate'],icon_size=[30, 30]) # moderate\n                elif avg_var >= var_limits[input.var()][2] and avg_var < var_limits[input.var()][3]:\n                    icon = L.Icon(icon_url = icons_urls['poor'],icon_size=[30, 30]) # poor\n                else:\n                    icon = L.Icon(icon_url = icons_urls['very_poor'],icon_size=[30, 30]) # very poor\n                \n                marker = L.Marker(location=(data_cities_lat_lon[city]['lat'], data_cities_lat_lon[city]['lon']),    # dodanie znacznika\n                                icon=icon,\n                                draggable=False)\n                map.add_layer(marker)\n\n    # When the slider changes, update the map's zoom attribute (2)\n    @reactive.Effect\n    def _():\n        map.zoom = input.zoom()\n\n    # When zooming directly on the map, update the slider's value (2 and 3)\n    @reactive.Effect\n    def _():\n        ui.update_slider(\"zoom\", value=reactive_read(map, \"zoom\"))\n\n    # funkcja znajduj\u0105ca miasta najbardziej i najmniej zaniczyszczone wybranym zwi\u0105zkiem\n    @reactive.Calc\n    def worst_best_pol():\n        df_time_sec = df_time_section()\n        avg_pollution = dict()\n        data_cities_lat_lon = reactive_city_lat_lon()\n\n        for city in data_cities_lat_lon:\n            df_copy = df_time_sec.loc[df_time_sec['city'] == city]\n\n            start = pd.to_datetime(df_copy['dt'].values[0]) + timedelta(hours = 8)\n            end = pd.to_datetime(df_copy['dt'].values[0]) + timedelta(hours = 20)\n\n            df_copy.set_index('dt', inplace=True)\n            df_new = df_copy[start:end]\n\n            avg = df_new[input.var()].mean()\n            avg_pollution[city] = avg\n        \n        worst = max(avg_pollution, key=avg_pollution.get)\n        best = min(avg_pollution, key=avg_pollution.get)\n\n        return [worst, best]\n\n    # funkcja do wy\u015bwietlania informacji\n    @output\n    @render.ui\n    def map_bounds():\n        if (input.var() != ''):\n            cities = worst_best_pol()\n        else:\n            cities = ['','']\n        return ui.p(f\"Highest pollution: {cities[0]}\", ui.br(), f\"Least pollution: {cities[1]}\")\n\napp = App(app_ui, server)", "type": "text"}, {"name": "instrukcja.md", "content": "1. Tworzenie foledru docs:\n- shinylive export shiny docs\n- python -m http.server --directory docs 8008\n2. Stawianie GitHubPages z tutorialu: https://github.com/RamiKrispin/shinylive/tree/main (2 screen)\n3. Potrzebne pliki:\n- data/csv/six_cities.csv\n- data/predictions/ar_seq2seq_pca.csv\n- data/variable_names.txt\n- data/city_list.txt\n", "type": "text"}, {"name": "shiny_download.py", "content": "import json\nfrom typing import Any, Literal\n\n\nclass HttpResponse:\n    def __init__(self, status: int, data: Any):\n        self.status = status\n        self.data = data\n\n\nasync def get_url(\n    url: str, type: Literal[\"string\", \"bytes\", \"json\"] = \"string\"\n) -> HttpResponse:\n    \"\"\"\n    An async wrapper function for http requests that works in both regular Python and\n    Pyodide.\n\n    In Pyodide, it uses the pyodide.http.pyfetch() function, which is a wrapper for the\n    JavaScript fetch() function. pyfetch() is asynchronous, so this whole function must\n    also be async.\n\n    In regular Python, it uses the urllib.request.urlopen() function.\n\n    Args:\n        url: The URL to download.\n\n        type: How to parse the content. If \"string\", it returns the response as a\n        string. If \"bytes\", it returns the response as a bytes object. If \"json\", it\n        parses the reponse as JSON, then converts it to a Python object, usually a\n        dictionary or list.\n\n    Returns:\n        A HttpResponse object\n    \"\"\"\n    import sys\n\n    if \"pyodide\" in sys.modules:\n        import pyodide.http\n\n        response = await pyodide.http.pyfetch(url)\n\n        if type == \"json\":\n            # .json() parses the response as JSON and converts to dictionary.\n            data = await response.json()\n        elif type == \"string\":\n            # .string() returns the response as a string.\n            data = await response.string()\n        elif type == \"bytes\":\n            # .bytes() returns the response as a byte object.\n            data = await response.bytes()\n\n        return HttpResponse(response.status, data)\n\n    else:\n        import urllib.request\n\n        response = urllib.request.urlopen(url)\n        if type == \"json\":\n            data = json.loads(response.read().decode(\"utf-8\"))\n        elif type == \"string\":\n            data = response.read().decode(\"utf-8\")\n        elif type == \"bytes\":\n            data = response.read()\n\n        return HttpResponse(response.status, data)\n", "type": "text"}]